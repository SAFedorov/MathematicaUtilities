(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(*A fix for usage messages, from http://mathematica.stackexchange.com/questions/3943/usage-displays-properly-only-after-second-call/27671#27671*)
System`Dump`fixmessagestring[System`Dump`s_]:=ToString@InputForm@System`Dump`s


\[Nu]FourierXY::usage = "\[Nu]FourierXY[xylist_], \[Nu]FourierXY[f_,xmin_,xmax_,\[Nu]max_]
	Compute numerical approximation of Fourier transform in linear units y[\[Nu]]=\!\(\*FractionBox[\(1\), SqrtBox[\(L\)]]\)\!\(\*SubsuperscriptBox[\(\[Integral]\), SubscriptBox[\(x\), \(0\)], \(\*SubscriptBox[\(x\), \(0\)] + L\)]\)y(x)Exp[\[ImaginaryI](2\[Pi]\[Nu])x]\[DifferentialD]x=\!\(\*FractionBox[\(dx\), SqrtBox[\(L\)]]\)\!\(\*UnderoverscriptBox[\(\[Sum]\), \(r = 1\), \(n - 1\)]\)y(\!\(\*SubscriptBox[\(x\), \(r\)]\))Exp[\[ImaginaryI](2\[Pi]\[Nu])\!\(\*SubscriptBox[\(x\), \(r\)]\)]
	Frequency is defined in linear units on the two-sided interval \[Nu]=s/dx, s\[Element][-(n-1)/2, (n-1)/2]
	In the case of odd n the spectrum contains equal number of positive and negative frequency components, 
	in the case of even n there is n/2 positive frequency components and n/2-1 negative frequency components

	If applied to a function of one variable f[x_] on the interval [\!\(\*SubscriptBox[\(x\), \(min\)]\), \!\(\*SubscriptBox[\(x\), \(max\)]\)], the function is disretized first with the step dx\[TildeTilde]\!\(\*FractionBox[\(2\), SubscriptBox[\(\[Nu]\), \(max\)]]\)"

\[Nu]FourierXY[xylist_?XYListQ]:=Module[{L,dx,n,nOS,\[Nu]List,ftyList},
	L=xylist[[-1,1]]-xylist[[1,1]](*interval length in x dimension*);
	n=Length[xylist];
	nOS=Floor[n/2](*define maximum positive frequency index*);
	dx=L/(n-1)(*step in x dimension*);
	\[Nu]List=1/L Range[-(n-1)+nOS,nOS];
	ftyList=Sqrt[dx]Fourier[xylist[[;;,2]]];
	ftyList=Join[ftyList[[nOS+2;;]],ftyList[[;;nOS+1]]](*by default the frequencies in Fourier[] span from 0 to (n-1)/L, here they are rearranged to form two-sided spectrum [(n/2-1)/L,(n/2-1)/L]*);
	Transpose[{\[Nu]List,ftyList}]
]

(* the version of \[Nu]FourierXY that acts on functions*)
\[Nu]FourierXY[f_?FunctionQ,xmin_,xmax_,\[Nu]max_]:=Module[{L,dx,n,xylist},
	L=(xmax-xmin);
	n=Ceiling[(\[Nu]max*2L)](*find the number of samples needed to calculate the spectrum up to the frequency \[Nu]max*);
	If[OddQ[n],n=n+1];
	dx=L/(n-1)(*step in x dimension*);
	xylist=Table[{xmin+k*dx,f[xmin+k*dx]},{k,0,n-1}];
	\[Nu]FourierXY[xylist]
]

\[Omega]FourierXY::usage = "\[Omega]FourierXY[xylist_], \[Nu]FourierXY[f_,xmin_,xmax_,\[Nu]max_]
	Analog of \[Nu]FourierXY that returns result with the x-axis in angular frequency units \[Omega]=2\[Pi]\[Times]\[Nu]"

\[Omega]FourierXY[args__]:=ScaleY[\[Nu]FourierXY[args],ScaleX->2\[Pi]]


OneFromTwoSidedSpectrum::usage = "OneFromTwoSidedSpectrum[sp_]
	Convert a two-sided spectrum at the input {{-\!\(\*SubscriptBox[\(\[Nu]\), \(n\)]\),\!\(\*SubsuperscriptBox[\(f\), \(n\), \(*\)]\)},{-\!\(\*SubscriptBox[\(\[Nu]\), \(n\)]\)+d\[Nu],\!\(\*SubsuperscriptBox[\(f\), \(n\), \(*\)]\)},...,{\!\(\*SubscriptBox[\(\[Nu]\), \(n\)]\),\!\(\*SubscriptBox[\(f\), \(n\)]\)}} to one-sided spectrum {{0,\!\(\*SubscriptBox[\(f\), \(0\)]\)'},...,{\!\(\*SubscriptBox[\(\[Nu]\), \(n\)]\),\!\(\*SubscriptBox[\(f\), \(n\)]\)'}}, where \!\(\*SubscriptBox[\(f\), \(0\)]\)'=\!\(\*SubscriptBox[\(f\), \(0\)]\), \!\(\*SubscriptBox[\(f\), \(n\)]\)'=2\!\(\*SubscriptBox[\(f\), \(n\)]\) 
	Works only with uniformly-spaced frequency components \!\(\*SubscriptBox[\(\[Nu]\), \(n\)]\).

Options:
	\[Epsilon]Zero\[Rule]\!\(\*SuperscriptBox[\(10\), \(-5\)]\) \[Dash] small number, characterizing the acceptable deviation from zero frequency"

OneFromTwoSidedSpectrum[sp_,OptionsPattern[\[Epsilon]Zero->10^-5]]:=Module[{d\[Nu],\[Nu]0,\[Epsilon],tmpSp,zero\[Nu]Element},
	\[Epsilon]=OptionValue[\[Epsilon]Zero];(*small number, characterizing the acceptable deviation from zero frequency*)
	d\[Nu]=sp[[2,1]]-sp[[1,1]];(*frequency step*)
	zero\[Nu]Element=Select[sp,(Abs[#[[1]]]<\[Epsilon] d\[Nu])&];
	If[Length[zero\[Nu]Element]!=1,
		Print["Multiple or no zero-frequency elements are found"];Return[{}],
		zero\[Nu]Element=zero\[Nu]Element[[1]]
	];
	tmpSp=Select[sp,(#[[1]]>0)&];
	Join[{zero\[Nu]Element},Transpose[{tmpSp[[;;,1]],2tmpSp[[;;,2]]}]]
]


SymmetrizeSpectrum::usage = "SymmetrizeSpectrum[sp_]
	Convert a two-sided spectrum at the input {{-\!\(\*SubscriptBox[\(\[Nu]\), \(n\)]\),\!\(\*SubscriptBox[\(f\), \(-n\)]\)},{-\!\(\*SubscriptBox[\(\[Nu]\), \(n\)]\)+d\[Nu],\!\(\*SubscriptBox[\(f\), \(-n\)]\)},...,{\!\(\*SubscriptBox[\(\[Nu]\), \(n\)]\),\!\(\*SubscriptBox[\(f\), \(n\)]\)}}\[IndentingNewLine]	to two-sided symmetrized spectrum {{-\!\(\*SubscriptBox[\(\[Nu]\), \(n\)]\),\!\(\*SubsuperscriptBox[\(f\), \(-n\), \('\)]\)},{-\!\(\*SubscriptBox[\(\[Nu]\), \(n\)]\)+d\[Nu],\!\(\*SubsuperscriptBox[\(f\), \(-n\), \('\)]\)},...,{\!\(\*SubscriptBox[\(\[Nu]\), \(n\)]\),\!\(\*SubscriptBox[SuperscriptBox[\(f\), \('\)], \(n\)]\)}}, where \!\(\*SubscriptBox[\(f\), \(0\)]\)'=\!\(\*SubscriptBox[\(f\), \(0\)]\), \!\(\*SubscriptBox[\(f\), \(n\)]\)'=(\!\(\*SubscriptBox[\(f\), \(n\)]\)+\!\(\*SubscriptBox[\(f\), \(-n\)]\))/2\[IndentingNewLine]	Works only with uniformly-spaced frequency components \!\(\*SubscriptBox[\(\[Nu]\), \(n\)]\)

Options:
	\[Epsilon]Zero\[Rule]\!\(\*SuperscriptBox[\(10\), \(-5\)]\) \[Dash] small number, characterizing the acceptable deviation from zero frequency"

SymmetrizeSpectrum[sp_,OptionsPattern[\[Epsilon]Zero->10^-5]]:=Module[{d\[Nu],\[Epsilon],zero\[Nu]ElementI,l,ret,\[Nu]List},
	\[Epsilon]=OptionValue[\[Epsilon]Zero];(*small number, characterizing the acceptable deviation from zero frequency*)
	d\[Nu]=sp[[2,1]]-sp[[1,1]];(*frequency step*)

	zero\[Nu]ElementI=Position[sp,{_?(Abs[#]<\[Epsilon]&),_}];
	If[Length[zero\[Nu]ElementI]!=1,Print[zero\[Nu]ElementI,"Multiple or no zero-frequency elements are found"];Return[{}],zero\[Nu]ElementI=zero\[Nu]ElementI[[1,1]]];
	l=Min[Length[sp]-zero\[Nu]ElementI,zero\[Nu]ElementI-1];
	\[Nu]List=Table[k d\[Nu],{k,-l,l,1}];
	(*number of frequency components, for which an opposite-frequency countepart exists*)
	ret=Table[(sp[[zero\[Nu]ElementI+i,2]]+sp[[zero\[Nu]ElementI-i,2]])/2,{i,0,l}];
	Transpose[{\[Nu]List,Join[Reverse[ret[[2;;]]],ret]}]
]
