(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(*A fix for usage messages, from http://mathematica.stackexchange.com/questions/3943/usage-displays-properly-only-after-second-call/27671#27671*)
System`Dump`fixmessagestring[System`Dump`s_]:=ToString@InputForm@System`Dump`s


RSMaximize::usage="RSMaximize[f_, varIntervalList_, nIterations_]
	Maximize the value of f_ using random search 

Input:
	f[\!\(\*SubscriptBox[\(x\), \(1\)]\),..,\!\(\*SubscriptBox[\(x\), \(i\)]\),..] - function to maximize\[IndentingNewLine]	varIntervalList={...,{\!\(\*SubscriptBox[\(x\), \(i\)]\),\!\(\*SubscriptBox[\(x\), \(i\\\ min\)]\),\!\(\*SubscriptBox[\(x\), \(i\\\ max\)]\)},...,{\!\(\*SubscriptBox[\(x\), \(j\)]\),{\!\(\*SubscriptBox[\(x\), \(j1\)]\),\!\(\*SubscriptBox[\(x\), \(j2\)]\),..}}...} - list of the variables of the function f with the ranges of 
		values they take (in the case of continuous variables) or the lists of discrete values (in the case of discrete variables).\[IndentingNewLine]	nIterations - number of random points

Output:
	{\!\(\*SubscriptBox[\(f\), \(max\)]\), {.., \!\(\*SubscriptBox[\(x\), \(i\)]\)\[Rule]\!\(\*SubscriptBox[\(x\), \(i . max . val\)]\), ...}}"
	
Begin["`Private`"]

RSMaximize[f_,varIntervalList_,nIterations_]:=Module[{tmpVarRuleList,tmpFOM,bestSol,exitNowQ},
	(*the temporary maximim value of f and the set of parameters at which it is achieved*)
	exitNowQ=False;
	(*Make button to break search midway without loosing result*)
	PrintTemporary[
		Button["Stop search",exitNowQ=True]
	];
	bestSol={0,{}};
	Do[
	(*Compose the replacement rules from lists of discrete and continuous variables*)
		tmpVarRuleList={};
		Do[
			tmpVarRuleList=Append[tmpVarRuleList,
				Which[
					MatchQ[varIntervalList[[j]],{_,_?ListQ}],varIntervalList[[j,1]]-> RandomChoice[varIntervalList[[j,2]]/.tmpVarRuleList],
					MatchQ[varIntervalList[[j]],{_,_,_}],varIntervalList[[j,1]]-> RandomReal[varIntervalList[[j,{2,3}]]/.tmpVarRuleList]
				]
			],
		{j,Length[varIntervalList]}];

		(*calculate the value of f at the current set of parameters*)
		tmpFOM=f/.tmpVarRuleList;
		If[(i==1||tmpFOM>bestSol[[1]]),
			bestSol={tmpFOM,tmpVarRuleList};
			PrintTemporary["Iteration=",i,", solution=",bestSol];
		];
		If[exitNowQ,Break[]];
		,
		{i,nIterations}
	];
	bestSol
]

End[]
