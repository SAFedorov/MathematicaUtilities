(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(*A fix for usage messages, from http://mathematica.stackexchange.com/questions/3943/usage-displays-properly-only-after-second-call/27671#27671*)
System`Dump`fixmessagestring[System`Dump`s_]:=ToString@InputForm@System`Dump`s


SetRamRestriction::usage = "SetRamRestriction[maxMemAllowedGB_:2,intervalBetweenTests_:5]
	Run a task that checks every intervalBetweenTests the amount of memory used by Mathematica kernel and aborts it if the limit is exceeded. 
	The function is used to prevent unlimited memory allocation by Mathematica that arises with certain programming mistakes when processing 
	large amounts of data and irreversibly hangs the entire computer.
	The function uses global variable ramBelowThresholdSignal as counter.

Output:
	ScheduledTaskObject which can be used stop the memory monitoring by RemoveScheduledTask[]"

Begin["`Private`"]

SetRamRestriction[maxMemAllowedGB_:2,intervalBetweenTests_:5]:=(
	ramBelowThresholdSignal=0;
	Print[Dynamic[ramBelowThresholdSignal]];
	RunScheduledTask[If[MemoryInUse[]>(maxMemAllowedGB 1024^3),Quit[],ramBelowThresholdSignal++],intervalBetweenTests]
)

End[]


PrintDefaultHeader::usage = "PrintDefaultHeader[]
	Print sequence of typical commands used in the beginning of notebook"

Begin["`Private`"]

PrintDefaultHeader[]:=NotebookWrite[InputNotebook[],{
Cell[CellGroupData[{
Cell["Header", "Section"],

Cell[BoxData[
 RowBox[{"SetDirectory", "[", 
  RowBox[{"NotebookDirectory", "[", "]"}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Get", "[", "\"\<savedWorkspace.wdx\>\"", "]"}], 
  RowBox[{"(*", 
   RowBox[{
   "load", " ", "definitions", " ", "of", " ", "variables", " ", 
    "from", " ", "file"}], "*)"}], ";"}]], "Input"],

Cell[BoxData[
 RowBox[{
  RowBox[{"DumpSave", "[", 
   RowBox[{"\"\<savedWorkspace.wdx\>\"", ",", "\"\<Global`\>\""}], 
   "]"}], 
  RowBox[{"(*", 
   RowBox[{
   "save", " ", "all", " ", "the", " ", "definitions", " ", "of", " ",
     "variables", " ", "to", " ", "a", " ", "file"}], "*)"}], 
  ";"}]], "Input"],

Cell[BoxData[
 RowBox[{
  RowBox[{"CreateCellIDs", "[", "]"}], 
  RowBox[{"(*", 
   RowBox[{
   "assign", " ", "IDs", " ", "to", " ", "notebook", " ", "cells", 
    " ", "for", " ", "use", " ", "with", " ", "ReEvaluateCells"}], 
   "*)"}], ";"}]], "Input"],

Cell[BoxData[
 RowBox[{
  RowBox[{"ramMonitoringTask", "=", 
   RowBox[{"SetRamRestriction", "[", "]"}]}], ";"}]], "Input"]
}, Open  ]],

Cell["Workspace", "Section"]
}]

End[]


compilationOptionsC::usage="Settings for Compile[] that are aimed for ultimate speedup of the compiled code. Use C code as target requires a C compiler to be installed on computer."

compilationOptionsC=Sequence[
	CompilationTarget->"C",
	CompilationOptions->{"InlineExternalDefinitions"->True},
	RuntimeOptions->{"EvaluateSymbolically"->False}
];


FunctionQ::usage="FunctionQ[expr_] tests if expression is a Function, CompiledFunction or InterpolatingFunction."

Begin["`Private`"]

(*Adopted from http://stackoverflow.com/questions/3736942/test-if-an-expression-is-a-function*)
FunctionQ[_Function|_InterpolatingFunction|_CompiledFunction]=True
FunctionQ[f_Symbol]:=Or[DownValues[f]=!={},MemberQ[Attributes[f],NumericFunction]]
FunctionQ[_]=False

End[]


(*Tests if the argument is a vector of numbers*)
NumericVectorQ::usage="NumericVectorQ[expr_] tests if expr is a vertor with all numeric elements"

Begin["`Private`"]
NumericVectorQ[expr_]:=VectorQ[expr,NumericQ]
End[]


notOptPatt::usage="Except[_?OptionQ]
	A pattern to test if the expression is NOT an option. 
	Typical usage is to define optional arguments in functions, which at the same time can accept options. 

Example:
	Definition of function with an optional argument y having the default value of 1 and at the same time an option Option1 with default value 2	
	f[x_, y:notOptPatt:1, OptionsPattern[{Option1->2}]]:=\!\(\*SuperscriptBox[\(x\), \(2\)]\)+y+OptionValue[Option1]"

notOptPatt=Except[_?OptionQ]


(*differentiate between 2D and 3D datasets*)
XYListQ::usage="XYListQ[list_], XYListQ[list_,d_]
	Test if list is a xylist of dimension d, d=1 if omitted."

Begin["`Private`"]

XYListQ[list_]:=ArrayQ[list,2]&&(Dimensions[list][[2]]==2)
XYListQ[list_,d_]:=ListQ[list]&& AllTrue[list,XYListQ,d-1]

End[]


(* ::Code::Initialization:: *)
XYZListQ::usage="XYZListQ[list_], XYZListQ[list_,d_]
	Test if list is and xyzlist of the dimension d, d=1 if omitted."

Begin["`Private`"]

XYZListQ[list_]:=ArrayQ[list,2]&&(Dimensions[list][[2]]==3)
XYZListQ[list_,d_]:=ListQ[list]&& AllTrue[list,XYZListQ,d-1]

End[]


InRangeQ::usage="InRangeQ[x_, range_, IncludeBoundary\[Rule]True]
	Check if x belongs to the interval range={\!\(\*SubscriptBox[\(x\), \(min\)]\), \!\(\*SubscriptBox[\(x\), \(max\)]\)}.

Options:
	IncludeBoundary\[Rule]True - regulate if the boundary points are included in the interval. 
	The option can be a single logical value or a list of 2 logical values (e.g. {True,False}), related to the low and high boundary correspondingly."

Options[InRangeQ]={IncludeBoundary->True}

Begin["`Private`"]

InRangeQ[x_,range_,OptionsPattern[{InRangeQ}]]:=Module[{upCompFunc,lowCompFunc,ibOpt},
	ibOpt=OptionValue[IncludeBoundary];
	Which[
		Head[ibOpt]===Symbol,
		lowCompFunc=If[ibOpt===True,GreaterEqual,Greater];
		upCompFunc=If[ibOpt===True,LessEqual,Less];
	,
		Head[ibOpt]===List,
		lowCompFunc=If[ibOpt[[1]]===True,GreaterEqual,Greater];
		upCompFunc=If[ibOpt[[2]]===True,LessEqual,Less];
	];
	lowCompFunc[x,range[[1]]]&&upCompFunc[x,range[[2]]]
];

End[]


(*Useful functions adopted with slight extension from the V.Sudhir's He3Analysis package;
The function names are self-explanatory, the two instances are different in the argument type.*)


MapX::usage="MapX[f_,list_] applies function f to X elements in xy- or xyz- list"
MapY::usage="MapY[f_,list_] applies function f to Y elements in xy- or xyz- list"
MapXY::usage="MapX[fx_,fy_,list_] applies functions fx and fy correspondingly to X and Y elements in xy- or xyz- list"
MapZ::usage="MapZ[f_,list_] applies function f to Z elements in xyzlist"

Begin["`Private`"]

MapX[f_,list_?XYListQ]:=Map[{f[#[[1]]],#[[2]]}&,list]
MapX[f_,list_?XYZListQ]:=Map[{f[#[[1]]],#[[2]],#[[3]]}&,list]

MapY[f_,list_?XYListQ]:=Map[{#[[1]],f[#[[2]]]}&,list]
MapY[f_,list_?XYZListQ]:=Map[{#[[1]],f[#[[2]]],#[[2]]}&,list]

MapXY[fx_,fy_,list_?XYListQ]:=Map[{fx[#[[1]]],fy[#[[2]]]}&,list]
MapXY[fx_,fy_,list_?XYZListQ]:=Map[{fx[#[[1]]],fy[#[[2]]],#[[3]]}&,list]

MapZ[f_,xyzlist_]:=Map[{#[[1]],#[[2]],f[#[[3]]]}&,xyzlist]

End[]


ScaleY::usage="ScaleX[list_,a_], ScaleY[list_,a_], ShiftX[list_,a_], ShiftY[list_,a_]
	rescale or offset data along the x and y coordinates by the amount a_
	Each of the function names can be used as an option in another. E.g. simultaneus shift along x axis by a and rescaling along 
	y by b can be equivalently written as ScaleY[list,b,ShiftX\[Rule]a] or ShiftX[list,b,ScaleY\[Rule]a].

Input:
	list_ is either xylist or xylistd2. a is a constant if list_ is xylist or if list_ is xylistd2, can be a vector of constants
	for each element in xylistd2. Specifically for ShiftY, a_ can be a xylist or a list of xylists, in which case the y-values 
	of this xylist are added to the y- values of list_.

Output: 
	{{x,y},...}\[Rule]{{ScaleX\[Times](x+ShiftX),ScaleY\[Times](y+ShiftY)},...}"
	
ScaleX::usage=ScaleY::usage
ShiftY::usage=ScaleY::usage
ShiftX::usage=ScaleY::usage

SSXY::usage="SSXY[list_,xSc_,ySc_,xSh_,ySh_] low level generic rescaling function used by ScaleY, ScaleX, ShiftY and ShiftX";

(*Versions for various inputs*)

Begin["`Private`"]
								
SSXY[xylist_?XYListQ,xSc_,ySc_,xSh_,ySh_]:=Which[
	XYListQ[ySh]&&(Length[ySh]==Length[xylist]),
		Transpose[{xSc (xylist[[;;,1]]+xSh),ySc (xylist[[;;,2]]+ySh[[;;,2]])}],
	True,
		Transpose[{xSc (xylist[[;;,1]]+xSh),ySc (xylist[[;;,2]]+ySh)}]
]
SSXY[list_?(XYListQ[#,2]&),xSc_,ySc_,xSh_,ySh_]:=Module[{xScListQ,yScListQ,xShListQ,yShListQ,xScTmp,yScTmp,xShTmp,yShTmp},
	(*Check if need to iterate over the variables*)
	xScListQ=(VectorQ[xSc]&&(Length[xSc]==Length[list]));
	yScListQ=(VectorQ[ySc]&&(Length[ySc]==Length[list]));
	xShListQ=(VectorQ[xSh]&&(Length[xSh]==Length[list]));
	(*The case of shift in y direction is special as here multiple xylists can be supplied*)
	yShListQ=((VectorQ[ySh]||XYListQ[ySh,2])&&(Length[ySh]==Length[list]));	
	Table[
		xScTmp=If[xScListQ, xSc[[i]], xSc];
		yScTmp=If[yScListQ, ySc[[i]], ySc];
		xShTmp=If[xShListQ, xSh[[i]], xSh];
		yShTmp=If[yShListQ, ySh[[i]], ySh];
		SSXY[list[[i]],xScTmp,yScTmp,xShTmp,yShTmp]
		,
		{i,Length[list]}
	]
]
		
ScaleY[list_, a:Except[_?OptionQ]:1, OptionsPattern[{ScaleX->1,ShiftX->0,ShiftY->0}]]:=Module[{xSc,ySc,xSh,ySh},
	xSc=OptionValue[ScaleX];
	ySc=a;
	xSh=OptionValue[ShiftX];
	ySh=OptionValue[ShiftY];	
	SSXY[list,xSc,ySc,xSh,ySh]
]
ScaleX[list_, a:Except[_?OptionQ]:1, OptionsPattern[{ScaleY->1,ShiftX->0,ShiftY->0}]]:=Module[{xSc,ySc,xSh,ySh},
	xSc=a;
	ySc=OptionValue[ScaleY];
	xSh=OptionValue[ShiftX];
	ySh=OptionValue[ShiftY];	
	SSXY[list,xSc,ySc,xSh,ySh]
]
ShiftY[list_, a:Except[_?OptionQ]:0, OptionsPattern[{ScaleX->1,ScaleY->1,ShiftX->0}]]:=Module[{xSc,ySc,xSh,ySh},
	xSc=OptionValue[ScaleX];
	ySc=OptionValue[ScaleY];
	xSh=OptionValue[ShiftX];
	ySh=a;	
	SSXY[list,xSc,ySc,xSh,ySh]
]
ShiftX[list_?XYListQ, a:Except[_?OptionQ]:0, OptionsPattern[{ScaleX->1,ScaleY->1,ShiftY->0}]]:=Module[{xSc,ySc,xSh,ySh},
	xSc=OptionValue[ScaleX];
	ySc=OptionValue[ScaleY];
	xSh=a;
	ySh=OptionValue[ShiftY];	
	SSXY[list,xSc,ySc,xSh,ySh]
]

End[]


NormalizeY::usage="NormalizeY[xylist_]
	Function accepts 2D array of data (xylist) and rescales it along Y coordinate to within [0,1]"

Begin["`Private`"]

NormalizeY[list_]:=
	Module[{ymin,ymax},
	ymin=Min[list[[;;,2]]];
	ymax=Max[list[[;;,2]]];
	Transpose[{list[[;;,1]],(list[[;;,2]]-(ymax+ymin)/2) 2/(ymax-ymin)}]
];

End[]


Average::usage="Average[list_, nAvg_]
	Function calculates moving average of the list and does a corresponding decimation of the list.
	The output thus consists of averages over successive intervals of nAvg elements. 
	The X-values for each of the averaging intervals are taken close to the centers of the interval\[IndentingNewLine]
	list_ can be
	1. a 1D list
	2. a xylist
	3. a xylistd2"
	
Begin["`Private`"]

Average[list_,nAvg_]:=Which[
	Depth[list]==2, 
	(*single 1D list input*)
	Take[MovingAverage[list,nAvg],{1,-1,nAvg}]
	,
	Depth[list]==3, 
	(*single XY trace input*)
	Take[Transpose[{list[[Ceiling[nAvg/2];;-Floor[nAvg/2]-1,1]],MovingAverage[list[[;;,2]],nAvg]}],{1,-1,nAvg}]
	,
	Depth[list]==4, 
	(*list of XY traces as input*)
	Table[Take[Transpose[{x[[Ceiling[nAvg/2];;-Floor[nAvg/2]-1,1]],MovingAverage[x[[;;,2]],nAvg]}],{1,-1,nAvg}],{x,list}]
]

End[]


GaussianAverage::usage="GaussianAverage[list_, nAvg_]
	Function calculates the Gaussian filtered signal. The output thus consists of averages over successive intervals of nAvg elements.

Input:
	list_ can be
	1. a 1D list
	2. a xylist
	3. a xylistd2
	In the latter two cases an appropriate the X-values for each of the averaging intervals are taken close to the centers of the interval"
	
Begin["`Private`"]

GaussianAverage[list_,nAvg_]:=
Which[
	Depth[list]==2, 
	(*single 1D list input*)
	GaussianFilter[list,nAvg]
	,
	Depth[list]==3, 
	(*single XY trace input*)
	Transpose[{list[[;;,1]],GaussianFilter[list[[;;,2]],nAvg]}]
	,
	Depth[list]==4, 
	(*list of XY traces as input*)
	Table[Transpose[{x[[;;,1]],GaussianFilter[x[[;;,2]],nAvg]}],{x,list}]
]

End[]


AverageXYLists::usage="AverageXYLists[xylistd2_]
	Computes average of y values for a set of xylists. Lists are aligned by the first element and trimmed to the minimum length among them. 
	"

Begin["`Private`"]

AverageXYLists[xylists_]:=Module[{nMin,nLists,ylist},
	nMin=Min[Map[Length,xylists]](*find minimum trace length*);
	nLists=Length[xylists];
	ylist=Total[xylists[[;;,;;nMin,2]],{1}]/nLists;
	Transpose[{xylists[[1,;;nMin,1]],ylist}]
]

End[]


FindPeaksXY::usage="FindPeaksXY[xylist_, \[Sigma]_:0, s_:0, t_:-\[Infinity]]
	Analog of FindPeaks that acts on xylists.

Output:
	Peak x position and y values {{\!\(\*SubscriptBox[\(x\), \(peak, i\)]\), \!\(\*SubscriptBox[\(y\), \(peak, i\)]\)},...}

Options:
	Those of standard FindPeaks plus
	PeakSign\[Rule]1, switches between looking for peaks (1) or valleys (-1)"

Options[FindPeaksXY]=Join[Options[FindPeaks],{PeakSign->1}]

Begin["`Private`"]

FindPeaksXY[xylist_,\[Sigma]:Except[_?OptionQ]:0,s:Except[_?OptionQ]:0,t:Except[_?OptionQ]:-\[Infinity],opts:OptionsPattern[]]:=
Module[{peakIndexList,peakValList,xInterp,peakSign},
	peakSign=Sign[OptionValue[PeakSign]];
	{peakIndexList,peakValList}=Transpose[FindPeaks[peakSign*xylist[[;;,2]],\[Sigma],s,t]];
	(*InterpolationOrder is an option of basic FindPeaks, so it also can be used to find x values*)
	xInterp=Interpolation[xylist[[;;,1]],InterpolationOrder->OptionValue[InterpolationOrder]];

	Transpose[{Thread[xInterp[peakIndexList]],peakValList}]
];

End[]


FindPeakCenter::usage="FindPeakCenter[list_]
	find x-position of the center of mass of xylist using linear data interpolation over x

Input:
	list_ is xylist or xylistd2

Options:
	PeakSign\[Rule]1, switches between looking for peak (1) or valley (-1)"

Options[FindPeakCenter]={PeakSign->1}

Begin["`Private`"]

FindPeakCenter[xylist_?XYListQ,opts:OptionsPattern[]]:=Module[{offset,yAccList,yInterpIntegral,indCOM},
	(*offset is subtracted for more robust peak search*)
	offset=If[OptionValue[PeakSign]>=0, Min[xylist[[;;,2]]], Max[xylist[[;;,2]]]];	
	yAccList=Accumulate[xylist[[;;,2]]-offset];	
	yInterpIntegral=Interpolation[yAccList/yAccList[[-1]]];	
	
	(*initial approximation is chosen to be in the interval center, 
	but it should not play role if the peak is single in the supplied xylist*)	
	(*indCOM - index, non necessarily integer, of the center of mass. It is better to find the peak position in dimensionless 
	units first not to suffer from numerical errors at small absolute values of x*)
	(*0.5 is added to indCOM explicitly in order to remove bias, introduced by Accumulate*)
	(*Also use Quiet for the numerical routine not to complain about slow convergence, there is little can be done about it*)
	(indCOM=0.5+(x/.FindRoot[yInterpIntegral[x]==0.5,{x,Length[yAccList]/2}]))//Quiet;
	
	(*Convert indCOM to x using linear interpolation*)
	(xylist[[Floor[indCOM],1]](Ceiling[indCOM]-indCOM)+xylist[[Ceiling[indCOM],1]](indCOM-Floor[indCOM]))/(Ceiling[indCOM]-Floor[indCOM])
]

(*Thread over first argument*)
FindPeakCenter[xylistd2_?(XYListQ[#,2]&),opts:OptionsPattern[]]:=Table[FindPeakCenter[xylist,opts],{xylist,xylistd2}]

End[]


IntegrateXY::usage = "IntegrateXY[xylist_, intRange_]
	Efficient interpolation-based numerical integration of a function represented as a list of {\!\(\*SubscriptBox[\(x\), \(i\)]\),\!\(\*SubscriptBox[\(y\), \(i\)]\)} values.

Input:
	xylist
	intRange - integration range specified as {\!\(\*SubscriptBox[\(x\), \(min\)]\), \!\(\*SubscriptBox[\(x\), \(max\)]\)}, {{\!\(\*SubscriptBox[\(x\), \(min1\)]\), \!\(\*SubscriptBox[\(x\), \(max1\)]\)}, {\!\(\*SubscriptBox[\(x\), \(min2\)]\), \!\(\*SubscriptBox[\(x\), \(max2\)]\)}} or Interval object

Options:
	Options of Interpolation[] 
"

Options[IntegrateXY]=Options[Interpolation]

Begin["`Private`"]

(*Integration range specified as {Subscript[x, min], Subscript[x, max]}*)
IntegrateXY[xylist_?XYListQ, intRange:{_?NumericQ,_?NumericQ}, opts:OptionsPattern[]]:=Module[{interpData,interpOpts},
	interpOpts=FilterRules[{opts}, Options[Interpolation]];
	(*Interpolate the entire data set. Pre-selection of points around the integration range in fact makes the overall procedure to consume more time.*)
	interpData=Interpolation[xylist, interpOpts];
	Integrate[interpData[x],{x,intRange[[1]],intRange[[2]]}]
]

(*Integration range specified as Interval*)
IntegrateXY[xylist_?XYListQ, intRange_Interval, opts:OptionsPattern[]]:=Sum[IntegrateXY[xylist,intRange[[i]],opts],{i,Length[intRange]}]

(*Integration range specified as {{Subscript[x, min1], Subscript[x, max1]}, {Subscript[x, min2], Subscript[x, max2]}} (in fact identical to the case of Interval)*)
IntegrateXY[xylist_?XYListQ, intRange_?XYListQ, opts:OptionsPattern[]]:=Sum[IntegrateXY[xylist,intRange[[i]],opts],{i,Length[intRange]}]

End[]


ReflectX::usage = "ReflectX[xylist_,x0_] reflects the x values of xylist with respect to x0"

Begin["`Private`"]
ReflectX[xylist_,x0_]:=Transpose[ {2x0-xylist[[;;,1]],xylist[[;;,2]]}]
End[]


(*From http://mathematica.stackexchange.com/questions/11345/can-mathematica-handle-open-intervals-interval-complements*)


IntervalInverse::usage="IntervalInverse[a_] returns complement (\[Minus]\[Infinity],\[Infinity])/a"

Begin["`Private`"]

IntervalInverse[Interval[int___]]:=Interval@@Partition[
	Flatten@{int}/.{{-\[Infinity],mid___,\[Infinity]}:>{mid},{-\[Infinity],mid__}:>{mid,\[Infinity]},{mid__,\[Infinity]}:>{-\[Infinity],mid},{mid___}:>{-\[Infinity],mid,\[Infinity]}},2]
	
End[]


IntervalComplement::usage="IntervalComplement[a_,b_,c_,..] returnes a\[Backslash](b\:222ac\:222a\[Ellipsis])"

Begin["`Private`"]

IntervalComplement[a_Interval,b__Interval]:=IntervalIntersection[a,IntervalInverse@IntervalUnion[b]]

End[]


FindLogFit::usage="FindLogFit[data_, expr_, rest__]. The function is equivalent to FindFit, but minimizes error on log Y scale."

Begin["`Private`"]

FindLogFit[data_,expr_,rest__]:=Module[{logData},
(*The function is equivalent to FindFit, but works in log Y scale*)
	logData=Which[
		VectorQ[data],Log[Abs[data]],(*data list*)
		XYListQ[data],Transpose[{data[[;;,1]],Log[Abs[data[[;;,2]]]]}], (*XY data*)
		True,{}
	];
	FindFit[logData,Log[expr],rest]
]

End[]


FitRangeSelector::usage="FitRangeSelector[fitRanges_, traceList_]
	Create an interactive plot to select intervals for each element in the traceList_ (presumably for future use in fitting)

Interactive operation:
	Left mouse click - set lower x interval boundary at current mouse cursor position
	Right mouse click - set upper x interval boundary at current mouse cursor position
	
Output:
	The list of ranges is assigned to fitRanges_

Options:
	LogYPlot\[Rule]False
	LogXPlot\[Rule]False"

Options[FitRangeSelector]={LogYPlot->False,LogXPlot->False};
SetAttributes[FitRangeSelector,HoldFirst];(*Hold attribute for the "fitRanges" variable is needed for being able to clear the variable if it was already defined*)

Begin["`Private`"]

FitRangeSelector[fitRanges_,traceList_,OptionsPattern[{FitRangeSelector}]]:=DynamicModule[{epList, LowerLine,UpperLine,minList,maxList,plotF},
	(*right and left cursor lines*)
	minList=Table[Min[tr[[;;,2]]],{tr,traceList}];
	maxList=Table[Max[tr[[;;,2]]],{tr,traceList}];
	LowerLine[i_,x_]:={CMYKColor[1.,0,0,.4],Line[{{x,2minList[[i]]},{x,2maxList[[i]]}}]};
	UpperLine[i_,x_]:={CMYKColor[0.,0.2,0.5,.1],Line[{{x,2minList[[i]]},{x,2maxList[[i]]}}]};
	plotF=Which[
		OptionValue[LogYPlot]&&OptionValue[LogXPlot],ListLogLogPlot,
		OptionValue[LogYPlot]&&(!OptionValue[LogXPlot]),ListLogPlot,
		(!OptionValue[LogYPlot])&&OptionValue[LogXPlot],ListLogLinearPlot,
		(!OptionValue[LogYPlot])&&(!OptionValue[LogXPlot]),ListPlot
	];

	(* epList is the list of cursors to display the chosen boundaries*)
	epList=Table[
		{LowerLine[i,traceList[[i,1,1]]],UpperLine[i,traceList[[i,-1,1]]]},
	{i,Length[traceList]}];
	
	Clear[fitRanges];
	fitRanges=Table[{0,0},{i,Length[traceList]}];

	Manipulate[
		EventHandler[plotF[traceList[[i]],Joined->True,ImageSize->Large,PlotRange->Full,Epilog->epList[[i]]],
			{{"MouseClicked",1}:>(
				fitRanges[[i,1]]=MousePosition["Graphics"][[1]];
				epList[[i]]={LowerLine[i,fitRanges[[i,1]]], epList[[i,2]]};
				)
			},
			{{"MouseClicked",2}:>(
				fitRanges[[i,2]]=MousePosition["Graphics"][[1]];
				epList[[i]]={ epList[[i,1]],UpperLine[i,fitRanges[[i,2]]]};
				)
			}
		],
		{i,1,Length[traceList],1}
	],
SaveDefinitions->True]

End[]


ThreadFindFit::usage="ThreadFindFit[traceList_,fitModel_,pars_,vars_,fitRanges_:Full]
	Function applies FindFit[] to each element in the list of 2D data traces traceList.

Input:
	fitModel_, pars_ and vars_ correspond to inputs for FindFit[]. fitModel_ and pars_ can be either a single element, 
	or a list of corresponding elements for each trace in traceList.
	fitRanges_ is an optional argument, if not specified then the entire data set is fitted. fitRanges_ can be
	1. single range {\!\(\*SubscriptBox[\(x\), \(min\)]\),\!\(\*SubscriptBox[\(x\), \(max\)]\)}
	2. a list of ranges {\!\(\*SubsuperscriptBox[\(x\), \(i\), \(min\)]\),\!\(\*SubsuperscriptBox[\(x\), \(i\), \(max\)]\)} for every traceList[[i]]
	3. a single Interval
	4. a list of Interval's for every traceList[[i]]

Output:
	list of the fit replacement rules for each trace in traceList_

Options: 
	FitFunction\[Rule]FindFit can be either FindFit (by default) of FindLogFit"

Options[ThreadFindFit]={FitFunction->FindFit};

Begin["`Private`"]

ThreadFindFit[traceList_,fitModel_,pars_,vars_,fitRanges:Except[_?OptionQ]:Full,OptionsPattern[{ThreadFindFit}]]:=Module[{dataList,fitModelsList,parsList,frIntervalsList},
	(*reduce the input parameters from all the various acceptable forms to a single one \[Dash] lists*)
	If[fitRanges===Full,
		(*if the entire traces are to be fitted*)
		dataList=traceList,
		
		(*if some range of x-values is to be selected first*)
		frIntervalsList=Which[
		(*case of single fit interval for all the traces*)
		(Head[fitRanges]===Interval),
			Table[fitRanges,{i,Length[traceList]}],
		(*case of individual fit intervals*)
		(Head[fitRanges]===List)&&(Head[fitRanges[[1]]]===Interval),
			fitRanges,
		(*case of single fit range for all the traces*)
		(Head[fitRanges]===List)&&(Head[fitRanges[[1]]]=!=Interval)&&(Depth[fitRanges]== 2), 
			Table[Interval[fitRanges],{i,Length[traceList]}],
		(*case of individual fit ranges*)
		(Head[fitRanges]===List)&&(Head[fitRanges[[1]]]===List)&&(Depth[fitRanges]== 3), 
			Table[Interval[fitRanges[[i]]],{i,Length[traceList]}]
		];
		dataList=Table[Select[traceList[[i]],IntervalMemberQ[frIntervalsList[[i]],#[[1]]]&],{i,Length[traceList]}];
	];
	fitModelsList=If[Head[fitModel]=!= List,
		Table[fitModel,{i,Length[traceList]}],
		fitModel
	];
	parsList=If[
		Depth[pars]<=2 ||(Depth[pars]==3 && DeleteDuplicates[Head/@Flatten[pars]]=!= {Symbol}) , Table[pars,{i,Length[traceList]}],
		Table[pars[[i]],{i,Length[traceList]}]
	];

	(*perform fitting*)
	Table[OptionValue[FitFunction][dataList[[i]],fitModelsList[[i]],parsList[[i]],vars],{i,Length[traceList]}]
];

End[]


FitQualityCheck::usage="FitQualityCheck[traceList_,fitRanges_,fitModel_,fitParameters_,fitVar_:x]
	Plots fits on top of the orifinal data.

Input:
	fitModel needs to have fitVar as the free variable
	fitRanges should be either a single fitting interval for all the traces in traceList, or the list of individual fitting intervals for traceList[[i]]

Options:
	LogYPlot\[Rule]False,
	LogXPlot\[Rule]False"

Options[FitQualityCheck]={LogYPlot->False,LogXPlot-> False};

Begin["`Private`"]

FitQualityCheck[traceList_,fitRanges_,fitModel_,fitParameters_,OptionsPattern[{FitQualityCheck}]]:=
Module[{xPlotRanges,cPlotF,dPlotF},
	If[Head[fitRanges]=!=List, Print["Fit ranges is not a list"];Return[]];
		xPlotRanges=Which[
			Depth[fitRanges]== 2, (*case of single fit range for all the traces*)
			Table[fitRanges,{i,Length[traceList]}],
			Depth[fitRanges]== 3, (*case of individual fit ranges*)
			Table[fitRanges[[i]],{i,Length[traceList]}]
		];

		cPlotF=Which[ (*chose continuous plotting function*)
			OptionValue[LogYPlot]&&OptionValue[LogXPlot],LogLogPlot,
			OptionValue[LogYPlot]&&(!OptionValue[LogXPlot]),LogPlot,
			(!OptionValue[LogYPlot])&&OptionValue[LogXPlot],LogLinearPlot,
			(!OptionValue[LogYPlot])&&(!OptionValue[LogXPlot]),Plot
		];
		dPlotF=Which[ (*chose discrete plotting function*)
			OptionValue[LogYPlot]&&OptionValue[LogXPlot],ListLogLogPlot,
			OptionValue[LogYPlot]&&(!OptionValue[LogXPlot]),ListLogPlot,
			(!OptionValue[LogYPlot])&&OptionValue[LogXPlot],ListLogLinearPlot,
			(!OptionValue[LogYPlot])&&(!OptionValue[LogXPlot]),ListPlot
		];

		Do[
			Print[i];
			Print[
				Show[
					dPlotF[traceList[[i]],PlotRange->{xPlotRanges[[i]],Full}],
					cPlotF[(fitModel)/.fitParameters[[i]],{Global`x,xPlotRanges[[i,1]],xPlotRanges[[i,2]]},PlotStyle->Directive[Red,Thin],PlotRange->Full]
				]
			],
		{i,Length[traceList]}]
]

End[]


LoadDataSeries::usage="LoadDataSeries[namePattern_,parNamesList_:{x}]
	Load a set of files with names, matching the namePattern_

Input: 
	namePattern_ containing varibles which values are being swept and parNamesList_ that lists these variables.
	In the case of single variable named x parNamesList may be omitted.  

Output: 
	{parList, dataList}, where dataList[[i]] corresponds to the content of the file with name including parList[[i]]
	parList={\!\(\*SubscriptBox[\(x\), \(1\)]\), \!\(\*SubscriptBox[\(x\), \(2\)]\), ... } in the case of single parameter and {{\!\(\*SubscriptBox[\(x\), \(1\)]\),\!\(\*SubscriptBox[\(y\), \(1\)]\),\!\(\*SubscriptBox[\(z\), \(1\)]\)},..} in the case of multiple
	
Options:
	By default the measurement files are loaded as Import[fileName,\"Table\"], custom loading function can be specified using FileLoadingFunction option, 
	which should return data if applied to file name
	By default the parameters in file names are interpreted as numbers, they can also be kept in text format by setting the InterpretParameter\[Rule]False.

Example: 
	LoadDataSeries[x__~~\" nW pickoff.txt\"]"

Options[LoadDataSeries]={InterpretParameter->True,FileLoadingFunction->Automatic,BaseDirectory->Directory[]}

Begin["`Private`"]

LoadDataSeries[namePattern_,parNamesList:Except[_?OptionQ]:{Global`x},OptionsPattern[{LoadDataSeries}]]:=Module[{fileNamesList,dir,FLF,parList,dataList,ret},
	dir=OptionValue[BaseDirectory];
	fileNamesList=FileNames[namePattern,dir,Infinity](*read file names and extract parameters from them*);
	(*parList=Flatten[ToExpression@StringCases[fileNamesList,namePattern->parNamesList],1];*)
	parList=Table[
		If[OptionValue[InterpretParameter],
			Interpreter["Number"][StringCases[fileName,namePattern->parNamesList][[1]]],
			StringCases[fileName,namePattern->parNamesList][[1]]
		],
		{fileName,fileNamesList}];
	
	(*read data from the files*)
	If[FunctionQ[OptionValue[FileLoadingFunction]],
		FLF=OptionValue[FileLoadingFunction],
		FLF=(Import[#,"Table"]&)];
	dataList=Table[FLF[fileName],{fileName,fileNamesList}];
	
	(*sort parameters and data sets according to increase in the first parameter in parList*)
	ret=Transpose@Sort[Transpose[{parList,dataList}],#1[[1,1]]<#2[[1,1]]&];
	
	(*If only one parameter, flatten the parList*)
	If[Length[parNamesList]>1,ret,{Flatten[ret[[1]]],ret[[2]]}]
]

End[]


SelectRange::usage="SelectRange[xylist_,xRange_], SelectRange[xylistd2_,xRange_]
	Return subset of xylist_ with x values within xRange_

Options:
	Accepts options of InRangeQ"

Options[SelectRange]=Options[InRangeQ]

Begin["`Private`"]

SelectRange[xylist_?XYListQ,xRange_,opts:OptionsPattern[{SelectRange}]]:=Select[xylist,(InRangeQ[#[[1]],xRange,opts])&];
SelectRange[xylistd2_?(XYListQ[#,2]&),xRange_,opts:OptionsPattern[{SelectRange}]]:=Table[Select[xylist,(InRangeQ[#[[1]],xRange,opts])&],{xylist,xylistd2}];

End[]
