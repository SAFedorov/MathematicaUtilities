(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



FunctionQ::usage="FunctionQ[expr_] tests if expression is a Function, CompiledFunction or InterpolatingFunction."
	
(*Adopted from http://stackoverflow.com/questions/3736942/test-if-an-expression-is-a-function*)
FunctionQ[_Function|_InterpolatingFunction|_CompiledFunction]=True
FunctionQ[f_Symbol]:=Or[DownValues[f]=!={},MemberQ[Attributes[f],NumericFunction]]
FunctionQ[_]=False


(*Tests if the argument is a vector or array of numbers*)
NumericVectorQ[expr_]:=VectorQ[expr,NumericQ]
NumericArrayQ[expr_]:=ArrayQ[expr,_,NumericQ]


notOptPatt::usage="Except[_?OptionQ]
	A pattern to test if the expression is NOT an option. 
	Typical usage is to define optional arguments in functions, which at the same time can accept options. 

Example:
	Definition of function with an optional argument y having the default value of 1 and at the same time an option Option1 with default value 2	
	f[x_, y:notOptPatt:1, OptionsPattern[{Option1->2}]]:=\!\(\*SuperscriptBox[\(x\), \(2\)]\)+y+OptionValue[Option1]"

notOptPatt=Except[_?OptionQ]


(*differentiate between 2D and 3D datasets*)
XYListQ::usage="XYListQ[list_], XYListQ[list_,d_]
	Test if list is a xylist of dimension d, d=1 if omitted."
	
XYListQ[list_]:=ArrayQ[list,2]&&(Dimensions[list][[2]]==2)
XYListQ[list_,d_]:=ListQ[list]&& AllTrue[list,XYListQ,d-1]


(* ::Code::Initialization:: *)
XYZListQ::usage="XYZListQ[list_], XYZListQ[list_,d_]
	Test if list is and xyzlist of the dimension d, d=1 if omitted."
	
XYZListQ[list_]:=ArrayQ[list,2]&&(Dimensions[list][[2]]==3)
XYZListQ[list_,d_]:=ListQ[list]&& AllTrue[list,XYZListQ,d-1]


(*Useful functions adopted with slight extension from the V.Sudhir's He3Analysis package;
The function names are self-explanatory, the two instances are different in the argument type.*)


MapX::usage="MapX[f_,list_] applies function f to X elements in xy- or xyz- list"
MapX[f_,list_?XYListQ]:=Map[{f[#[[1]]],#[[2]]}&,list]
MapX[f_,list_?XYZListQ]:=Map[{f[#[[1]]],#[[2]],#[[3]]}&,list]

MapY::usage="MapY[f_,list_] applies function f to Y elements in xy- or xyz- list"
MapY[f_,list_?XYListQ]:=Map[{#[[1]],f[#[[2]]]}&,list]
MapY[f_,list_?XYZListQ]:=Map[{#[[1]],f[#[[2]]],#[[2]]}&,list]

MapXY::usage="MapX[fx_,fy_,list_] applies functions fx and fy correspondingly to X and Y elements in xy- or xyz- list"
MapXY[fx_,fy_,list_?XYListQ]:=Map[{fx[#[[1]]],fy[#[[2]]]}&,list]
MapXY[fx_,fy_,list_?XYZListQ]:=Map[{fx[#[[1]]],fy[#[[2]]],#[[3]]}&,list]

MapZ::usage="MapZ[f_,list_] applies function f to Z elements in xyzlist"
MapZ[f_,xyzlist_]:=Map[{#[[1]],#[[2]],f[#[[3]]]}&,xyzlist]


ScaleY::usage="Function rescales data along the y coordinate by the factor of a_
	Also, a shift in y-dimension, or scaling and shift in x dimension can be specified by options ShiftY, ScaleX and ShiftX
	Output is calculated as: {x,y}\[Rule]{ScaleX\[Times](x+ShiftX),a\[Times](y+ShiftY)}

	Input list_ can be either xylist of a set of xylist's 

	a_ is a constant for single-list input, or may be a list of constants in the case of multiple list input.
	In the latter case Subscript[y, i]^j is scaled by Subscript[a, j]

	ScaleX and ShiftX can be constant only

	ShiftY can be a constant, a list or a xylist.
	In the case of list Subscript[ShiftY, i] is added to the Subscript[y, i] of the data
	In the case of a xylist, the y-values of this list are added to the y-values of the data."
ScaleX::usage=ScaleY::usage
ShiftY::usage=ScaleY::usage
ShiftX::usage=ScaleY::usage

SSXY::usage="SSXY[xylist_,xSc_,ySc_,xSh_,ySh_] generic rescaling function"
		
SSXY[xylist_,xSc_,ySc_,xSh_,ySh_]:=Module[{},
	Which[
		ArrayQ[ySh,2]&&(Length[ySh]==Length[xylist]),
			Transpose[{xSc (xylist[[;;,1]]+xSh),ySc (xylist[[;;,2]]+ySh[[;;,2]])}],
		True,
			Transpose[{xSc (xylist[[;;,1]]+xSh),ySc (xylist[[;;,2]]+ySh)}]
	]
]
		
ScaleY[xylist_?XYListQ, a:Except[_?OptionQ]:1, OptionsPattern[{ScaleX->1,ShiftX->0,ShiftY->0}]]:=Module[{xSc,ySc,xSh,ySh},
	xSc=OptionValue[ScaleX];
	ySc=a;
	xSh=OptionValue[ShiftX];
	ySh=OptionValue[ShiftY];	
	SSXY[xylist,xSc,ySc,xSh,ySh]
]

ScaleY[list_?(XYListQ[#,2]&),a:Except[_?OptionQ]:1,opts:OptionsPattern[{ScaleX->1,ShiftX->0,ShiftY->0}]]:=Module[{},
	If[ListQ[a],
		Table[ScaleY[list[[i]],a[[i]],opts],{i,Length[list]}],
		Table[ScaleY[xylist,a,opts],{xylist,list}]
	]
]

ScaleX[xylist_?XYListQ, a:Except[_?OptionQ]:1, OptionsPattern[{ScaleY->1,ShiftX->0,ShiftY->0}]]:=Module[{xSc,ySc,xSh,ySh},
	xSc=a;
	ySc=OptionValue[ScaleY];
	xSh=OptionValue[ShiftX];
	ySh=OptionValue[ShiftY];	
	SSXY[xylist,xSc,ySc,xSh,ySh]
]
ShiftY[xylist_?XYListQ, a:Except[_?OptionQ]:0, OptionsPattern[{ScaleX->1,ScaleY->1,ShiftX->0}]]:=Module[{xSc,ySc,xSh,ySh},
	xSc=OptionValue[ScaleX];
	ySc=OptionValue[ScaleY];
	xSh=OptionValue[ShiftX];
	ySh=a;	
	SSXY[xylist,xSc,ySc,xSh,ySh]
]
ShiftX[xylist_?XYListQ, a:Except[_?OptionQ]:0, OptionsPattern[{ScaleX->1,ScaleY->1,ShiftY->0}]]:=Module[{xSc,ySc,xSh,ySh},
	xSc=OptionValue[ScaleX];
	ySc=OptionValue[ScaleY];
	xSh=a;
	ySh=OptionValue[ShiftY];	
	SSXY[xylist,xSc,ySc,xSh,ySh]
]


(*From http://mathematica.stackexchange.com/questions/11345/can-mathematica-handle-open-intervals-interval-complements*)


IntervalInverse::usage="IntervalInverse[a_] returns complement (\[Minus]\[Infinity],\[Infinity])/a"

IntervalInverse[Interval[int___]]:=Interval@@Partition[
	Flatten@{int}/.{{-\[Infinity],mid___,\[Infinity]}:>{mid},{-\[Infinity],mid__}:>{mid,\[Infinity]},{mid__,\[Infinity]}:>{-\[Infinity],mid},{mid___}:>{-\[Infinity],mid,\[Infinity]}},2]


IntervalComplement::usage="IntervalComplement[a_,b_,c_,..] returnes a\[Backslash](b\:222ac\:222a\[Ellipsis])"

IntervalComplement[a_Interval,b__Interval]:=IntervalIntersection[a,IntervalInverse@IntervalUnion[b]]


FindLogFit::usage="FindLogFit[data_, expr_, rest__]. The function is equivalent to FindFit, but works in log Y scale."

FindLogFit[data_,expr_,rest__]:=Module[{logData},
(*The function is equivalent to FindFit, but works in log Y scale*)
	logData=Which[
		VectorQ[data],Log[Abs[data]],(*data list*)
		XYListQ[data],Transpose[{data[[;;,1]],Log[Abs[data[[;;,2]]]]}], (*XY data*)
		True,{}
	];
	FindFit[logData,Log[expr],rest]
]


FitRangeSelector::usage="FitRangeSelector[fitRanges_,traceList_,OptionsPattern[{logYPlot->False,logXPlot-> False}]]
	Function allows to select ranges for each element of the list of traces (presumably for future use in fitting)
	Left click - set lower x interval boundary at current mouse position; right click - set upper x interval boundary at current mouse position.
	fitRanges is an empty variable to which the list of ranges will be assigned."

SetAttributes[FitRangeSelector,HoldFirst];(*Hold attribute for the "fitRanges" variable is needed for being able to clear the variable if it was already defined*)
FitRangeSelector[fitRanges_,traceList_,OptionsPattern[{logYPlot->False,logXPlot-> False}]]:=DynamicModule[{epList, LowerLine,UpperLine,minList,maxList,plotF},
	(*right and left cursor lines*)
	minList=Table[Min[tr[[;;,2]]],{tr,traceList}];
	maxList=Table[Max[tr[[;;,2]]],{tr,traceList}];
	LowerLine[i_,x_]:={CMYKColor[1.,0,0,.4],Line[{{x,2minList[[i]]},{x,2maxList[[i]]}}]};
	UpperLine[i_,x_]:={CMYKColor[0.,0.2,0.5,.1],Line[{{x,2minList[[i]]},{x,2maxList[[i]]}}]};
	plotF=Which[
		OptionValue[logYPlot]&&OptionValue[logXPlot],ListLogLogPlot,
		OptionValue[logYPlot]&&(!OptionValue[logXPlot]),ListLogPlot,
		(!OptionValue[logYPlot])&&OptionValue[logXPlot],ListLogLinearPlot,
		(!OptionValue[logYPlot])&&(!OptionValue[logXPlot]),ListPlot
	];

	(* epList is the list of cursors to display the chosen boundaries*)
	epList=Table[
	{LowerLine[i,traceList[[i,1,1]]],UpperLine[i,traceList[[i,-1,1]]]}
	,{i,Length[traceList]}];
	Clear[fitRanges];
	fitRanges=Table[{0,0},{i,Length[traceList]}];

	Manipulate[
	EventHandler[plotF[traceList[[i]],Joined-> True,ImageSize->Large,PlotRange->Full,Epilog-> epList[[i]]],
	{{"MouseClicked",1}:>(
		fitRanges[[i,1]]=MousePosition["Graphics"][[1]];
		epList[[i]]={LowerLine[i,fitRanges[[i,1]]], epList[[i,2]]};
		)},
	{{"MouseClicked",2}:>(
		fitRanges[[i,2]]=MousePosition["Graphics"][[1]];
		epList[[i]]={ epList[[i,1]],UpperLine[i,fitRanges[[i,2]]]};
		)}
	],
	{i,1,Length[traceList],1}],
SaveDefinitions->True]


FindFitSeries::usage="FindFitSeries[traceList_,fitModel_,pars_,vars_,fitRanges_:Full]
	Function applies FindFit[] to each element in the list of 2D data traces traceList.

Input:
	fitModel, pars and vars are the corresponding elements for FindFit[]. fitModel and pars can be either a single element, or a list of corresponding elements for each trace in traceList.
	fitRanges is an optional argument, alowing pre-selection of the data to be fitted. It can be
	1. single range {Subscript[x, min],Subscript[x, max]}
	2. a list of ranges {\!\(\*SubsuperscriptBox[\(x\), \(i\), \(min\)]\),\!\(\*SubsuperscriptBox[\(x\), \(i\), \(max\)]\)} for every traceList[[i]]
	3. a single Interval
	4. a list of Interval's for every traceList[[i]]

Output:
	list of the fit replacement rules 

Options: 
	FitFunction can be either FindFit (by default) of FindLogFit"


FindFitSeries[traceList_,fitModel_,pars_,vars_,fitRanges:Except[_?OptionQ]:Full,OptionsPattern[{FitFunction->FindFit}]]:=Module[{dataList,fitModelsList,parsList,frIntervalsList},
	(*reduce the input parameters from all the various acceptable forms to a single one \[Dash] lists*)
	If[fitRanges===Full,
		(*if the entire traces are to be fitted*)
		dataList=traceList,
		
		(*if some range of x-values is to be selected first*)
		frIntervalsList=Which[
		(*case of single fit interval for all the traces*)
		(Head[fitRanges]===Interval),
			Table[fitRanges,{i,Length[traceList]}],
		(*case of individual fit intervals*)
		(Head[fitRanges]===List)&&(Head[fitRanges[[1]]]===Interval),
			fitRanges,
		(*case of single fit range for all the traces*)
		(Head[fitRanges]===List)&&(Head[fitRanges[[1]]]=!=Interval)&&(Depth[fitRanges]== 2), 
			Table[Interval[fitRanges],{i,Length[traceList]}],
		(*case of individual fit ranges*)
		(Head[fitRanges]===List)&&(Head[fitRanges[[1]]]===List)&&(Depth[fitRanges]== 3), 
			Table[Interval[fitRanges[[i]]],{i,Length[traceList]}]
		];
		dataList=Table[Select[traceList[[i]],IntervalMemberQ[frIntervalsList[[i]],#[[1]]]&],{i,Length[traceList]}];
	];
	fitModelsList=If[Head[fitModel]=!= List,
		Table[fitModel,{i,Length[traceList]}],
		fitModel
	];
	parsList=If[
		Depth[pars]<=2 ||(Depth[pars]==3 && DeleteDuplicates[Head/@Flatten[pars]]=!= {Symbol}) , Table[pars,{i,Length[traceList]}],
		Table[pars[[i]],{i,Length[traceList]}]
	];

	(*perform fitting*)
	Table[OptionValue[FitFunction][dataList[[i]],fitModelsList[[i]],parsList[[i]],vars],{i,Length[traceList]}]
];



FitQualityCheck::usage="FitQualityCheck[traceList_,fitRanges_,fitModel_,fitParameters_,fitVar_:x]
	Plots fits on top of the orifinal data.

Input:
	fitModel needs to have fitVar as the free variable
	fitRanges should be either a single fitting interval for all the traces in traceList, or the list of individual fitting intervals for traceList[[i]]

Options:
	logYPlot->False,
	logXPlot->False"

FitQualityCheck[traceList_,fitRanges_,fitModel_,fitParameters_,fitVar:Except[_?OptionQ]:Global`x,OptionsPattern[{logYPlot->False,logXPlot-> False}]]:=
Module[{xPlotRanges,cPlotF,dPlotF},
	If[Head[fitRanges]=!=List, Print["Fit ranges is not a list"];Return[]];
		xPlotRanges=Which[
			Depth[fitRanges]== 2, (*case of single fit range for all the traces*)
			Table[fitRanges,{i,Length[traceList]}],
			Depth[fitRanges]== 3, (*case of individual fit ranges*)
			Table[fitRanges[[i]],{i,Length[traceList]}]
		];

		cPlotF=Which[ (*chose continuous plotting function*)
			OptionValue[logYPlot]&&OptionValue[logXPlot],LogLogPlot,
			OptionValue[logYPlot]&&(!OptionValue[logXPlot]),LogPlot,
			(!OptionValue[logYPlot])&&OptionValue[logXPlot],LogLinearPlot,
			(!OptionValue[logYPlot])&&(!OptionValue[logXPlot]),Plot
		];
		dPlotF=Which[ (*chose discrete plotting function*)
			OptionValue[logYPlot]&&OptionValue[logXPlot],ListLogLogPlot,
			OptionValue[logYPlot]&&(!OptionValue[logXPlot]),ListLogPlot,
			(!OptionValue[logYPlot])&&OptionValue[logXPlot],ListLogLinearPlot,
			(!OptionValue[logYPlot])&&(!OptionValue[logXPlot]),ListPlot
		];

		Do[
			Print[i];
			Print[
				Show[
					dPlotF[traceList[[i]],PlotRange->{xPlotRanges[[i]],Full}],
					cPlotF[(fitModel)/.fitParameters[[i]],{fitVar,xPlotRanges[[i,1]],xPlotRanges[[i,2]]},PlotStyle->Directive[Red,Thin],PlotRange->Full]
				]
			],
		{i,Length[traceList]}]
]
