(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(*A fix for usage messages, from http://mathematica.stackexchange.com/questions/3943/usage-displays-properly-only-after-second-call/27671#27671*)
System`Dump`fixmessagestring[System`Dump`s_]:=ToString@InputForm@System`Dump`s


ComsolImport::usage = "ComsolImport[file] imports the .txt file with table results exported by COMSOL.
	ComsolImport[file, \"Headers\"] imports column headers of the table.
	ComsolImport[file, \"Info\"] gives the additional information stored in the file."
	 
Begin["`Private`"]

(*Helper methods*)
(* count of comment lines in exported file *)
CountCommentLines[file_String] := Module[{st, line, i},
	st = OpenRead[file];
	line = Read[st, String];
	i = 1;
	While[ StringMatchQ[line, StartOfString ~~ "%" ~~ __] && line =!= EndOfFile, 
		line = Read[st, String];
		i = i + 1;
	];
	Close[st];
	i
]

ComsolImport[file_String?FileExistsQ] := ComsolImport[file, "Table"] ;

(* import file, but skip unnecessary information *)
ComsolImport[file_String?FileExistsQ, "Table"] := Module[{impStr},
	(*read the input as text and change the number format to Matemathica-readable*)
	impStr=StringReplace[Import[file, "Plaintext"],{"i"->"*I","E"->"*10^"}];
	ToExpression[ImportString[impStr, "Table"][[CountCommentLines[file] ;; ]]] 
]

(* import only column headers *)
ComsolImport[file_String?FileExistsQ, "Headers"] := 
	ImportString[ StringDrop[ 
		Import[file, {"Text", "Lines", CountCommentLines[file] -1}],
	1], "Table" , "FieldSeparators"-> "  "];

(* get files information *)
ComsolImport[file_String?FileExistsQ, "Info"|"Information"] := 
	StringDrop[# , 1] &/@ Import[file, {"Text", "Lines", Range[CountCommentLines[file] -2]}] ;
	
End[]


SplitParametricSweepTable::usage = "SplitParametricSweepTable[list_,nPars_]
	Transform table {{\!\(\*SubscriptBox[\(s\), \(1\)]\), \!\(\*SubscriptBox[\(s\), \(2\)]\), ..., \!\(\*SubscriptBox[\(x\), \(1\)]\), \!\(\*SubscriptBox[\(x\), \(2\)]\),...},...} to a new form {\!\(\*SubscriptBox[\(s\), \(1\)]\), {..{\!\(\*SubscriptBox[\(s\), \(n\)]\),{\!\(\*SubscriptBox[\(x\), \(1\)]\), \!\(\*SubscriptBox[\(x\), \(2\)]\),...},...}...}} 
	where each of the parameters \!\(\*SubscriptBox[\(s\), \(1\)]\) runs over its own list dimension. Useful for processing results of COMSOL
	parametric sweep. 

Input:
	nPar_ is the number of parameters \!\(\*SubscriptBox[\(s\), \(i\)]\)"
	
Begin["`Private`"]

SplitParametricSweepTable[list_?MatrixQ, 1]:=Module[{par1ValList},
	par1ValList=DeleteDuplicates[list[[;;,1]]];
	Table[
		{par1,Select[list,(#[[1]]==par1)&][[;;,2;;]]},
		{par1,par1ValList}
	]
]
SplitParametricSweepTable[list_?MatrixQ,nPars_?((#>1)&)]:=Module[{par1ValList,subList},
	par1ValList=DeleteDuplicates[list[[;;,1]]];
	Table[
		subList=Select[list,(#[[1]]==par1)&][[;;,2;;]];
		{par1,SplitParametricSweepTable[subList, nPars-1]},
		{par1,par1ValList}
	]
]

End[]


SplitByModes::usage = "SplitByModes[list_] Useful for processing results of COMSOL parametric sweep."

Begin["`Private`"]

SplitByModes[list_]:=Module[{par1, nModes},
	par1=list[[1,1]];
	nModes=Count[list,{par1,__},1];
	Table[Take[list,{i,-1,nModes}],{i,1,nModes}]
]

End[]


TriangularElementMeshIntegrate::usage = "TriangularElementMeshIntegrate[fList_,mesh_] 
	Integrate the function f which is given as a set of values \!\(\*SubscriptBox[\(f\), \(i\)]\) on vertices {\!\(\*SubscriptBox[\(x\), \(i\)]\),\!\(\*SubscriptBox[\(y\), \(i\)]\)} of a mesh over all the 2D triangular elements of the mesh.
	Integral is computed using the 1-st order formula, i.e. as a sum over the mesh triangles. The aim of this function is to provide
		1. a fast and simple routine for integration of 2D functions, specified on mesh vertices
		2. without a loss of efficiency, provide a way to limit the integration region by selecting only specific mesh triangles\[IndentingNewLine]
Input:
	fList={\!\(\*SubscriptBox[\(f\), \(1\)]\),...,\!\(\*SubscriptBox[\(f\), \(n\)]\)} is the list of function values on the vertices given by the mesh[\"Coordinates\"]
	mesh_ is an ElementMesh object

Options:\[IndentingNewLine]	SelectedMeshElements is the list of indices of the mesh triangles to be included in the integration region. All elements are included by default\[IndentingNewLine]"

Begin["`Private`"]

TriangularElementMeshIntegrate[fList_,mesh_,OptionsPattern[{SelectedMeshElements-> All}]]:=Module[{indices,measures,selMeshElements},
(*
For integration use the 1-st order formula:;
*)

	selMeshElements=OptionValue[SelectedMeshElements];
	indices=mesh["MeshElements"]/.{TriangleElement[t_]}:>Flatten[t[[selMeshElements]]];
	measures=mesh["MeshElementMeasure"][[1,selMeshElements]];
	Total[Total[Partition[fList[[indices]],3],{2}]*measures/3]
]

End[]


TetrahedralElementMeshIntegrate::usage = "TetrahedralElementMeshIntegrate[fList_,mesh_] 
	Integrate the function f which is given as a set of values \!\(\*SubscriptBox[\(f\), \(i\)]\) on vertices {\!\(\*SubscriptBox[\(x\), \(i\)]\),\!\(\*SubscriptBox[\(y\), \(i\)]\)} of a mesh over all the 2D triangular elements of the mesh.
	Integral is computed using the 1-st order formula, i.e. as a sum over the mesh tetrahedrons. The aim of this function is to provide
		1. a fast and simple routine for integration of 3D functions, specified on mesh vertices
		2. without a loss of efficiency, provide a way to limit the integration region by selecting only specific mesh tetrahedrons\[IndentingNewLine]
Input:
	fList={\!\(\*SubscriptBox[\(f\), \(1\)]\),...,\!\(\*SubscriptBox[\(f\), \(n\)]\)} is the list of function values on the vertices given by the mesh[\"Coordinates\"]
	mesh_ is an ElementMesh object

Options:\[IndentingNewLine]	SelectedMeshElements is the list of indices of the mesh triangles to be included in the integration region. All elements are included by default\[IndentingNewLine]"

Begin["`Private`"]

TetrahedralElementMeshIntegrate[fList_,mesh_,OptionsPattern[{SelectedMeshElements-> All}]]:=Module[{indices,measures,selMeshElements},
	selMeshElements=OptionValue[SelectedMeshElements];
	indices=mesh["MeshElements"]/.{TetrahedronElement[t_]}:>Flatten[t[[selMeshElements]]];
	measures=mesh["MeshElementMeasure"][[1,selMeshElements]];
	Total[Total[Partition[fList[[indices]],4],{2}]*measures/4]
]

End[]
